---
title: 3. Frågor som omfattar flera tabeller
slug: osa3
sections:
- Tabellreferenser
- Liitostaulut
- JOIN-syntaksi
---

# 3. Frågor som omfattar flera tabeller

## Tabellreferenser

En central idé inom databaser är att en rad i en tabell kan referera till en rad i en annan tabell. Således kan man skapa frågor som samlar data från flera tabeller utifrån dessa referenser. I praktiken består en sådan referens oftast av ID-numret för raden i den andra tabellen.

### Exempel

Låt oss som exempel titta på en situation där databasen innehåller information om kurser och deras lärare. Vi antar att varje kurs har en lärare, och att samma lärare kan undervisa flera kurser.

Vi sparar information om lärarna i tabellen `Teachers`. Varje lärare har ett ID-nummer som vi kan referera till.

```sql
CREATE TABLE Teachers (
  id INTEGER PRIMARY KEY,
  name TEXT
);
```

Tabellen kan exempelvis se ut på följande sätt:

```
id  name      
--  ----------
1   Kaila     
2   Luukkainen
3   Kivinen   
4   Laaksonen 
```

Tabellen `Courses` innehåller information om kurserna. För varje kurs finns en referens till kursens lärare.

```sql
CREATE TABLE Courses (
  id INTEGER PRIMARY KEY,
  name TEXT,
  teacher_id INTEGER REFERENCES Teachers
);
```

Här refererar kolumnen `teacher_id` till ID-numret för en rad i tabellen `Teachers`, vilket anges med `REFERENCES Teachers`.

Tabellen kan exempelvis se ut på följande sätt:

```
id  name                    teacher_id
--  ----------------        ----------
1   Beräkningsmodeller      3         
2   Datanätverk             1         
3   Seminarium              1         
4   PHP-programmering       4         
5   Neuronnät               3         
```

Detta innebär att till exempel kursen Beräkningsmodeller undervisas av läraren med ID-numret 3. Från tabellen `Teachers` framgår att denna lärare är Kivinen.

Vi kan nu hämta kurserna med deras lärare med följande fråga som samtidigt hämtar information från tabellerna `Courses` och `Teachers`:

```sql
SELECT
  Courses.name, Teachers.name
FROM
  Courses, Teachers
WHERE
  Courses.teacher_id = Teachers.id;
```

Eftersom frågan involverar flera tabeller anger vi vilken tabell varje kolumn tillhör. Till exempel refererar `Courses.name` till kolumnen `name` i tabellen `Courses`.

Frågan ger följande svar:

```
name                    name     
----------------        ---------
Beräkningsmodeller      Kivinen  
Datanätverk             Kaila    
Seminarium              Kaila    
PHP-programmering       Laaksonen
Neuronnät               Kivinen  
```

### Vad hände i exemplet ovan?

Frågan ovan omfattar flera tabeller (`FROM Courses, Teachers`) men vad innebär det egentligen?

Idén är att när en fråga omfattar flera tabeller är utgångspunkten för resultattabellen _alla de olika möjliga sätten_ att kombinera rader från tabellerna. Därefter kan man med villkoren i `WHERE`-delen bestämma vilka radkombinationer som är av intresse.

Ett bra sätt för att förstå hur en fråga med flera tabeller fungerar är att först titta på en fråga som hämtar alla kolumner och som inte innehåller någon `WHERE`-del. I exemplet ovan är en sådan fråga följande:

```sql
SELECT * FROM Courses, Teachers;
```

Eftersom tabellen `Courses` har 5 rader och tabellen `Teachers` har 4 rader blir svaret en resultattabell på 5 * 4 = 20 rader. Resultattabellen innehåller alla möjliga sätt att först välja en rad från tabellen `Courses` och sedan en rad från tabellen `Teachers`:

```
id  name               teacher_id  id  name      
--  ----------------   ----------  --  ---------
1   Beräkningsmodeller  3          1   Kaila     
1   Beräkningsmodeller  3          2   Luukkainen
1   Beräkningsmodeller  3          3   Kivinen   
1   Beräkningsmodeller  3          4   Laaksonen 
2   Datanätverk         1          1   Kaila     
2   Datanätverk         1          2   Luukkainen
2   Datanätverk         1          3   Kivinen   
2   Datanätverk         1          4   Laaksonen 
3   Seminarium          1          1   Kaila     
3   Seminarium          1          2   Luukkainen
3   Seminarium          1          3   Kivinen   
3   Seminarium          1          4   Laaksonen 
4   PHP-programmering   4          1   Kaila     
4   PHP-programmering   4          2   Luukkainen
4   PHP-programmering   4          3   Kivinen   
4   PHP-programmering   4          4   Laaksonen 
5   Neuronnät           3          1   Kaila     
5   Neuronnät           3          2   Luukkainen
5   Neuronnät           3          3   Kivinen   
5   Neuronnät           3          4   Laaksonen 
```

De flesta resultatrader är dock inte av intresse eftersom deras information inte hör ihop sinsemellan. Till exempel berättar den första resultatraden bara att det finns en kurs som heter Beräkningsmodeller och att det finns en lärare som heter Kaila.

För att filtrera fram de rader som ger oss användbar information begränsar vi sökningen så att lärarens id-nummer ska vara samma i båda tabellerna:

```sql
SELECT
  *
FROM
  Courses, Teachers
WHERE
  Courses.teacher_id = Teachers.id;
```

Nu ger frågan svar som är mer intressanta:

```
id  name                teacher_id  id  name     
--  ----------------    ----------  --  ---------
1   Beräkningsmodeller  3           3   Kivinen  
2   Datanätverk         1           1   Kaila    
3   Seminarium          1           1   Kaila    
4   PHP-programmering   4           4   Laaksonen
5   Neuronnät           3           3   Kivinen  
```

Vi kan ytterligare precisera svarstabellen genom att välja de kolumner som är av intresse:

```sql
SELECT
  Courses.name, Teachers.name
FROM
  Courses, Teachers
WHERE
  Courses.teacher_id = Teachers.id;
```

På så sätt kommer vi fram till samma svar som tidigare:

```
name                name     
----------------    ---------
Beräkningsmodeller  Kivinen  
Datanätverk         Kaila    
Seminarium          Kaila    
PHP-programmering   Laaksonen
Neuronnät           Kivinen  
```

### Fler villkor

I frågor som involverar flera tabeller kopplar `WHERE`-delen ihop de rader i tabellerna som är av intresse för oss. Vi kan också lägga till andra villkor i `WHERE`-delen på samma sätt som tidigare. Till exempel kan vi ställa följande fråga:

```sql
SELECT
  Courses.name, Teachers.name
FROM
  Courses, Teachers
WHERE
  Courses.teacher_id = Teachers.id AND Teachers.name = 'Kivinen';
```

På så sätt får vi fram de kurser där Kivinen är lärare:
```
name                name   
----------------    -------
Beräkningsmodeller  Kivinen
Neuronnät           Kivinen
```

### Korta namn för tabellerna

Vi kan göra frågor som involverar flera tabeller mer lättlästa genom att ge tabellerna alternativa korta namn som vi sedan kan hänvisa till. Exempelvis frågan

```sql
SELECT
  Courses.name, Teachers.name
FROM
  Courses, Teachers
WHERE
  Courses.teacher_id = Teachers.id;
```

kan förkortas enligt följande:

```sql
SELECT
  C.name, T.name
FROM
  Courses AS C, Teachers AS T
WHERE
  C.teacher_id = T.id;
```

Ordet `AS` är inte nödvändigt att använda. Vi kan alltså förkorta frågan ytterligare:

```sql
SELECT
  C.name, T.name
FROM
  Courses C, Teachers T
WHERE
  C.teacher_id = T.id;
```

### Att upprepa samma tabell

I en fråga som involverar flera tabeller kan samma tabell också förekomma flera gånger så länge varje tabell som upprepas får ett annat namn. Till exempel hämtar följande fråga alla sätt att välja ett _par_ av två lärare:

```sql
SELECT A.name, B.name FROM Teachers A, Teachers B;
```

Frågan ger följande svar:

```
name        name      
----------  ----------
Kaila       Kaila     
Kaila       Luukkainen
Kaila       Kivinen   
Kaila       Laaksonen 
Luukkainen  Kaila     
Luukkainen  Luukkainen
Luukkainen  Kivinen   
Luukkainen  Laaksonen 
Kivinen     Kaila     
Kivinen     Luukkainen
Kivinen     Kivinen   
Kivinen     Laaksonen 
Laaksonen   Kaila     
Laaksonen   Luukkainen
Laaksonen   Kivinen   
Laaksonen   Laaksonen 
```

## Länkningstabeller

Mellan tabeller finns det i allmänhet två typer av relationer: 

1. _Yksi moneen -suhde_:
   Taulun A rivi liittyy enintään yhteen taulun B riviin.
   Taulun B rivi voi liittyä useaan taulun A riviin.

2. _Monta moneen -suhde_:
   Taulun A rivi voi liittyä useaan taulun B riviin.
   Taulun B rivi voi liittyä useaan taulun A riviin.

Tapauksessa 1 voimme lisätä tauluun A sarakkeen, joka viittaa tauluun B, kuten teimme edellisen osion esimerkissä. Tapauksessa 2 tilanne on kuitenkin hankalampi, koska yksittäinen viittaus kummankaan taulun rivissä ei riittäisi. Ratkaisuna on luoda kolmas _liitostaulu_ (_join table_), joka sisältää tiedot viittauksista.

### Esimerkki

Tarkastellaan esimerkkinä tilannetta, jossa verkkokaupassa on tuotteita ja asiakkaita ja jokainen asiakas on valinnut tiettyjä tuotteita ostoskoriin. Tietyn asiakkaan korissa voi olla useita tuotteita, ja toisaalta tietty tuote voi olla usean asiakkaan korissa.

Rakennamme tietokannan, jossa on kolme taulua: `Products`, `Customers` ja `Purchases`. Liitostaulu `Purchases` ilmaisee, mitä tuotteita on kunkin asiakkaan ostoskorissa. Sen jokainen rivi esittää yhden parin muotoa "asiakkaan _id_ korissa on tuote _id_".

Oletetaan, että taulujen sisällöt ovat seuraavat:

{: .inline title="Products" }
| id  | name | price |
| -- | -- | -- |
| 1 | retiisi | 7 |
| 2 | porkkana | 5 |
| 3 | nauris | 4 |
| 4 | lanttu | 8 |
| 5 | selleri | 4 |

{: .inline title="Customers" }
| id  | name |
| -- | -- |
| 1 | Uolevi |
| 2 | Maija |
| 3 | Aapeli |

{: .inline title="Purchases" }
| customer_id | product_id |
| -- | -- |
| 1 | 2 |
| 1 | 5 |
| 2 | 1 |
| 2 | 4 |
| 2 | 5 |

Tämä tarkoittaa, että Uolevin korissa on porkkana ja selleri sekä Maijan korissa on retiisi, lanttu ja selleri. Aapelin korissa ei ole mitään tuotetta.

Nyt voimme hakea asiakkaat ja tuotteet seuraavasti:

```sql
SELECT
  Customers.name, Products.name
FROM
  Customers, Products, Purchases
WHERE
  Customers.id = Purchases.customer_id AND
  Products.id = Purchases.product_id;
```

Kyselyn ideana on hakea tauluista `Customers` ja `Products` taulun `Purchases` rivejä vastaavat tiedot. Jotta saamme mielekkäitä tuloksia, kytkemme rivit yhteen kahden ehdon avulla. Kysely tuottaa seuraavan tulostaulun:

```
name    name    
------  --------
Uolevi  porkkana
Uolevi  selleri 
Maija   retiisi 
Maija   lanttu  
Maija   selleri 
```

### Miten kysely toimii?

Voimme taas tutkia kyselyn toimintaa hakemalla kaikki sarakkeet ja poistamalla ehdot:

```sql
SELECT * FROM Customers, Products, Purchases;
```

Tämän kyselyn tulostaulussa on kaikki tavat valita jokin asiakas, tuote ja ostokset. Tulostaulussa on 5 * 3 * 5 = 75 riviä ja se alkaa näin:


```
id  name    id  name      price  customer_id  product_id
--  ------  --  --------  -----  -----------  ----------
1   Uolevi  1   retiisi   7      1            2         
1   Uolevi  1   retiisi   7      1            5         
1   Uolevi  1   retiisi   7      2            1         
1   Uolevi  1   retiisi   7      2            4         
1   Uolevi  1   retiisi   7      2            5         
1   Uolevi  2   porkkana  5      1            2         
1   Uolevi  2   porkkana  5      1            5         
1   Uolevi  2   porkkana  5      2            1         
1   Uolevi  2   porkkana  5      2            4         
1   Uolevi  2   porkkana  5      2            5         
1   Uolevi  3   nauris    4      1            2         
1   Uolevi  3   nauris    4      1            5         
1   Uolevi  3   nauris    4      2            1         
1   Uolevi  3   nauris    4      2            4         
1   Uolevi  3   nauris    4      2            5         
...
```

Sitten kun lisäämme kyselyyn ehdot, saamme rajattua kiinnostavat rivit:

```sql
SELECT
  *
FROM
  Customers, Products, Purchases
WHERE
  Customers.id = Purchases.customer_id AND
  Products.id = Purchases.product_id;
```

```
id  name    id  name      price  customer_id  product_id
--  ------  --  --------  -----  -----------  ----------
1   Uolevi  2   porkkana  5      1            2         
1   Uolevi  5   selleri   4      1            5         
2   Maija   1   retiisi   7      2            1         
2   Maija   4   lanttu    8      2            4         
2   Maija   5   selleri   4      2            5         
```

Kun vielä määritämme halutut sarakkeet, tuloksena on lopullinen kysely:

```sql
SELECT
  Customers.name, Products.name
FROM
  Customers, Products, Purchases
WHERE
  Customers.id = Purchases.customer_id AND
  Products.id = Purchases.product_id;
```

```
name    name    
------  --------
Uolevi  porkkana
Uolevi  selleri 
Maija   retiisi 
Maija   lanttu  
Maija   selleri 
```

### Lisää ehtoja kyselyyn

Voimme lisätä kyselyyn lisää ehtoja, jos haluamme saada selville muuta ostoskoreista. Esimerkiksi seuraava kysely hakee Maijan korissa olevat tuotteet:

```sql
SELECT
  Products.name
FROM
  Customers, Products, Purchases
WHERE
  Customers.id = Purchases.customer_id AND
  Products.id = Purchases.product_id AND
  Customers.name = 'Maija';
```

```
name
----------
retiisi   
lanttu    
selleri   
```

Seuraava kysely puolestaan kertoo, keiden korissa on selleri:

```sql
SELECT
  Customers.name
FROM
  Customers, Products, Purchases
WHERE
  Customers.id = Purchases.customer_id AND
  Products.id = Purchases.product_id AND
  Products.name = 'selleri';
```

```
name
----------
Uolevi    
Maija    
```

### Yhteenveto tauluista

Voimme käyttää koostefunktioita ja ryhmittelyä myös usean taulun kyselyissä. Ne käsittelevät tulostaulua samalla periaatteella kuin yhden taulun kyselyissä.

Tarkastellaan edelleen tietokantaa, jossa on tuotteita, asiakkaita ja ostoksia:

{: .inline title="Products" }
| id  | name | price |
| -- | -- | -- |
| 1 | retiisi | 7 |
| 2 | porkkana | 5 |
| 3 | nauris | 4 |
| 4 | lanttu | 8 |
| 5 | selleri | 4 |

{: .inline title="Customers" }
| id  | name |
| -- | -- |
| 1 | Uolevi |
| 2 | Maija |
| 3 | Aapeli |

{: .inline title="Purchases" }
| customer_id | product_id |
| -- | -- |
| 1 | 2 |
| 1 | 5 |
| 2 | 1 |
| 2 | 4 |
| 2 | 5 |

Seuraava kysely luo yhteenvedon, joka näyttää jokaisesta asiakkaasta, montako tuotetta hänen ostoskorissaan on ja mikä on tuotteiden yhteishinta.

```sql
SELECT
  Customers.name, COUNT(Products.id), SUM(Products.price)
FROM
  Customers, Products, Purchases
WHERE
  Customers.id = Purchases.customer_id AND Products.id = Purchases.product_id
GROUP BY
  Customers.id;
```

Kyselyn tulos on seuraava:

```
name    COUNT(Products.id)  SUM(Products.price)
------  ------------------  -------------------
Uolevi  2                   9                  
Maija   3                   19                 
```

Uolevin korissa on siis 2 tavaraa, joiden yhteishinta on 9, ja Maijan korissa on 3 tavaraa, joiden yhteishinta on 19.

### Miten kysely toimii?

Kyselyn perusta on tässä:

```sql
SELECT
  *
FROM
  Customers, Products, Purchases
WHERE
  Customers.id = Purchases.customer_id AND Products.id = Purchases.product_id;
```

```
id  name    id  name      price  customer_id  product_id
--  ------  --  --------  -----  -----------  ----------
1   Uolevi  2   porkkana  5      1            2         
1   Uolevi  5   selleri   4      1            5         
2   Maija   1   retiisi   7      2            1         
2   Maija   4   lanttu    8      2            4         
2   Maija   5   selleri   4      2            5         
```

Kun kyselyyn lisätään ryhmittely `GROUP BY Customers.id`, rivit jakautuvat kahteen ryhmään sarakkeen `Customers.id` mukaan:

**Ryhmä 1:**

```
id  name    id  name      price  customer_id  product_id
--  ------  --  --------  -----  -----------  ----------
1   Uolevi  2   porkkana  5      1            2         
1   Uolevi  5   selleri   4      1            5         
```

**Ryhmä 2:**

```
id  name   id  name     price  customer_id  product_id
--  -----  --  -------  -----  -----------  ----------
2   Maija  1   retiisi  7      2            1         
2   Maija  4   lanttu   8      2            4         
2   Maija  5   selleri  4      2            5         
```

Näille ryhmille lasketaan sitten tuotteiden määrä `COUNT(Products.id)` sekä ostosten yhteishinta `SUM(Products.price)`.

Huomaa, että kyselyssä ryhmittely tapahtuu sarakkeen `Customers.id` mukaan, mutta kyselyssä haetaan sarake `Customers.name`. Tämä on sinänsä järkevää, koska sarake `Customers.id` määrää sarakkeen `Customers.name`. Tämä kysely toimii esimerkiksi SQLitessä, mutta jotkin tietokannat vaativat tässäkin tapauksessa, että sellaisenaan haettavan sarakkeen tulee esiintyä myös ryhmittelyssä. Tällöin ryhmittelyn tulisi olla `GROUP BY Customers.id, Customers.name`.

### Puuttuvan rivin ongelma

Äskeinen kysely toimii sinänsä hyvin, mutta jotain puuttuu:

```
name    COUNT(Products.id)  SUM(Products.price)
------  ------------------  -------------------
Uolevi  2                   9                  
Maija   3                   19                 
```

Kyselyn puutteena on vielä, että tuloksissa ei ole lainkaan kolmatta tietokannassa olevaa asiakasta eli Aapelia. Koska Aapelin korissa ei ole mitään, Aapelin rivi ei yhdisty minkään muun rivin kanssa eikä pääse osaksi tulostaulua.

Olemme törmänneet ongelmaan, mutta onneksi löydämme siihen ratkaisun pian.

## JOIN-syntaksi

Tähän mennessä olemme hakeneet tietoa tauluista listaamalla taulut kyselyn `FROM`-osassa, mikä toimii yleensä hyvin. Kuitenkin joskus on tarpeen `JOIN`-syntaksi, josta on hyötyä silloin, kun kyselyn tuloksesta näyttää "puuttuvan" tietoa.

### Kyselytavat

Seuraavassa on kaksi tapaa toteuttaa sama kysely, ensin käyttäen ennestään tuttua tapaa ja sitten käyttäen `JOIN`-syntaksia.

```sql
SELECT
  Courses.name, Teachers.name
FROM
  Courses, Teachers
WHERE
  Courses.teacher_id = Teachers.id;
```

```sql
SELECT
  Courses.name, Teachers.name
FROM
  Courses JOIN Teachers ON Courses.teacher_id = Teachers.id;
```

`JOIN`-syntaksissa taulujen nimien välissä esiintyy sana `JOIN` ja lisäksi taulujen rivit toisiinsa kytkevä ehto annetaan erillisessä `ON`-osassa.

Tässä tapauksessa `JOIN`-syntaksi on vain vaihtoehtoinen tapa toteuttaa kysely eikä se tuo mitään uutta. Kuitenkin näemme seuraavaksi, miten voimme laajentaa syntaksia niin, että se antaa meille uusia mahdollisuuksia kyselyissä.

### Esimerkki

Tarkastellaan esimerkkinä tilannetta, jossa tietokannassa on tutut taulut `Courses` ja `Teachers`, mutta taulussa `Courses` yhdeltä kurssilta puuttuu opettaja:

```
id  name              teacher_id
--  ----------------  ----------
1   Laskennan mallit  3         
2   Tietoverkot       1         
3   Graduseminaari    1         
4   PHP-ohjelmointi   NULL      
5   Neuroverkot       3         
```

Rivin 4 sarakkeessa `teacher_id` on arvo `NULL`, joten jos suoritamme jommankumman äskeisen kyselyn, ongelmaksi tulee, että rivi 4 ei täsmää mihinkään taulun `Teachers` riviin. Tämän seurauksena tulostauluun ei tule riviä kurssista PHP-ohjelmointi:

```
name              name   
----------------  -------
Laskennan mallit  Kivinen
Tietoverkot       Kaila  
Graduseminaari    Kaila  
Neuroverkot       Kivinen
```

Ratkaisu ongelmaan on käyttää `LEFT JOIN` -syntaksia, joka tarkoittaa, että mikäli jokin vasemman taulun rivi ei yhdisty mihinkään oikean taulun riviin, kyseinen vasemman taulun rivi pääsee silti mukaan yhdeksi riviksi tulostauluun. Kyseisellä rivillä jokaisen oikeaan tauluun perustuvan sarakkeen arvona on `NULL`.

Tässä tapauksessa voimme toteuttaa kyselyn näin:

```sql
SELECT
  Courses.name, Teachers.name
FROM
  Courses LEFT JOIN Teachers ON Courses.teacher_id = Teachers.id;
```

Nyt tulostauluun ilmestyy myös kurssi Tietokantojen perusteet ilman opettajaa:

```
name              name   
----------------  -------
Laskennan mallit  Kivinen
Tietoverkot       Kaila  
Graduseminaari    Kaila  
PHP-ohjelmointi   NULL   
Neuroverkot       Kivinen
```

### Miten kysely toimii?

Jälleen hyvä tapa saada selkoa kyselystä on yksinkertaistaa sitä:

```sql
SELECT
  *
FROM
  Courses LEFT JOIN Teachers ON Courses.teacher_id = Teachers.id;
```

```
id  name              teacher_id  id    name   
--  ----------------  ----------  ----  -------
1   Laskennan mallit  3           3     Kivinen
2   Tietoverkot       1           1     Kaila  
3   Graduseminaari    1           1     Kaila  
4   PHP-ohjelmointi   NULL        NULL  NULL   
5   Neuroverkot       3           3     Kivinen
```

Tästä näkee, että koska vasemman taulun rivi 4 ei täsmää mihinkään oikean taulun riviin, niin kyseisestä rivistä tulee tulostauluun yksi rivi, jossa jokainen sarake oikean taulun osuudessa on `NULL`.

### JOIN-kyselyperhe

Itse asiassa `JOIN`-kyselystä on olemassa peräti neljä eri muunnelmaa:

* `JOIN` eli `INNER JOIN`: toimii kuten tavallinen kahden taulun kysely
* `LEFT JOIN`: jos vasemman taulun rivi ei yhdisty mihinkään oikean taulun riviin,
  se valitaan kuitenkin mukaan erikseen
* `RIGHT JOIN`: jos oikean taulun rivi ei yhdisty mihinkään vasemman taulun riviin,
  se valitaan kuitenkin mukaan erikseen
* `FULL JOIN`: sekä vasemmasta että oikeasta taulusta valitaan erikseen mukaan
  rivit, jotka eivät yhdisty toisen taulun riviin

SQLiten rajoituksena on, että vain kaksi ensimmäistä kyselytapaa ovat mahdollisia. Onneksi `LEFT JOIN` on yleensä se, mitä haluamme.

### ON vs. WHERE

Sana `ON` on oleellinen `LEFT JOIN` -kyselyssä, koska se asettaa ehdon niin, että mukaan otetaan myös vasemman taulun ylimääräiset rivit:

```sql
SELECT
  Courses.name, Teachers.name
FROM
  Courses LEFT JOIN Teachers ON Courses.teacher_id = Teachers.id;
```

```
name              name   
----------------  -------
Laskennan mallit  Kivinen
Tietoverkot       Kaila  
Graduseminaari    Kaila  
PHP-ohjelmointi   NULL   
Neuroverkot       Kivinen
```

Jos käytämme sen sijasta sanaa `WHERE`, vasemman taulun ylimääräiset rivit jäävät pois:

```sql
SELECT
  Courses.name, Teachers.name
FROM
  Courses LEFT JOIN Teachers
WHERE
  Courses.teacher_id = Teachers.id;
```

```
name              name   
----------------  -------
Laskennan mallit  Kivinen
Tietoverkot       Kaila  
Graduseminaari    Kaila  
Neuroverkot       Kivinen
```

Sinänsä kyselyssä voi esiintyä sekä `ON` että `WHERE`:

```sql
SELECT
  Courses.name, Teachers.name
FROM
  Courses LEFT JOIN Teachers ON Courses.teacher_id = Teachers.id
WHERE
  Courses.name <> 'Tietoverkot';
```

Tällöin `ON`-osa hoitaa taulujen yhdistämisen ja `WHERE`-osa rajaa tuloksia lisää:

```
name              name   
----------------  -------
Laskennan mallit  Kivinen
Graduseminaari    Kaila  
PHP-ohjelmointi   NULL   
Neuroverkot       Kivinen
```

Tässä tapauksessa `WHERE`-osan vaikutuksena on, että tulostaulussa ei ole riviä, jossa kurssina on Tietoverkot.

Jos molemmat ehdot ovatkin `ON`-osassa, kyselyn tulos muuttuu taas:

```sql
SELECT
  Courses.name, Teachers.name
FROM
  Courses LEFT JOIN Teachers
          ON Courses.teacher_id = Teachers.id AND
             Courses.name <> 'Tietoverkot';
```

```
name              name   
----------------  -------
Laskennan mallit  Kivinen
Tietoverkot       NULL   
Graduseminaari    Kaila  
PHP-ohjelmointi   NULL   
Neuroverkot       Kivinen
```

Tässä tapauksessa kursseja Tietoverkot ja PHP-ohjelmointi vastaavat rivit jäävät ylimääräisiksi vasemmassa taulussa, koska niitä ei voida liittää mihinkään oikean taulun riviin `ON`-ehdossa.

### Yhteenveto toimivaksi

Nyt voimme pureutua aiempaan ongelmaan, jossa yhteenvetokyselystä puuttui tietoa. Tietokannassamme on edelleen seuraavat taulut:

{: .inline title="Products" }
| id  | name | price |
| -- | -- | -- |
| 1 | retiisi | 7 |
| 2 | porkkana | 5 |
| 3 | nauris | 4 |
| 4 | lanttu | 8 |
| 5 | selleri | 4 |

{: .inline title="Customers" }
| id  | name |
| -- | -- |
| 1 | Uolevi |
| 2 | Maija |
| 3 | Aapeli |

{: .inline title="Purchases" }
| customer_id | product_id |
| -- | -- |
| 1 | 2 |
| 1 | 5 |
| 2 | 1 |
| 2 | 4 |
| 2 | 5 |

Muodostimme yhteenvedon ostoskoreista seuraavalla kyselyllä:

```sql
SELECT
  Customers.name, COUNT(Products.id), SUM(Products.price)
FROM
  Customers, Products, Purchases
WHERE
  Customers.id = Purchases.customer_id AND Products.id = Purchases.product_id
GROUP BY
  Customers.id;
```

Kuitenkin ongelmaksi tuli, että Aapeli puuttuu yhteenvedosta:

```
name    COUNT(Products.id)  SUM(Products.price)
------  ------------------  -------------------
Uolevi  2                   9                  
Maija   3                   19                 
```

Ongelman syynä on, että Aapelin ostoskori on tyhjä eli kun kysely valitsee yhdistelmiä taulujen riveistä, ei ole mitään sellaista riviä, jolla esiintyisi Aapeli. Ratkaisu ongelmaan on käyttää `LEFT JOIN` -syntaksia näin:

```sql
SELECT
  Customers.name, COUNT(Products.id), SUM(Products.price)
FROM
  Customers LEFT JOIN Purchases ON Customers.id = Purchases.customer_id
            LEFT JOIN Products ON Products.id = Purchases.product_id
GROUP BY
  Customers.id;
```

Nyt myös Aapeli ilmestyy mukaan yhteenvetoon:

```
name    COUNT(Products.id)  SUM(Products.price)
------  ------------------  -------------------
Uolevi  2                   9                  
Maija   3                   19                 
Aapeli  0                   NULL               
```

Koska Aapelin ostoskorissa ei ole tuotteita, hintojen summaksi tulee `NULL`. Voimme vielä parantaa kyselyä `IFNULL`-funktion avulla:

```sql
SELECT
  Customers.name, COUNT(Products.id), IFNULL(SUM(Products.price), 0)
FROM
  Customers LEFT JOIN Purchases ON Customers.id = Purchases.customer_id
            LEFT JOIN Products ON Products.id = Purchases.product_id
GROUP BY
  Customers.id;
```

Tämän seurauksena mahdollinen `NULL` muuttuu arvoksi 0:

```
name    COUNT(Products.id)  IFNULL(SUM(Products.price), 0)
------  ------------------  ------------------------------
Uolevi  2                   9                             
Maija   3                   19                            
Aapeli  0                   0                             
```

### Miten kysely toimii?

Kun kyselyssä on useita `LEFT JOIN` -osia, tulkintana on, että ne yhdistävät tauluja vasemmalta oikealle. Yllä olevassa kyselyssä voimme ajatella, että ensimmäinen vaihe yhdistää taulut `Customers` ja `Purchases`:

```sql
SELECT
  *
FROM
  Customers LEFT JOIN Purchases ON Customers.id = Purchases.customer_id;
```

```
id  name    customer_id  product_id
--  ------  -----------  ----------
1   Uolevi  1            2         
1   Uolevi  1            5         
2   Maija   2            1         
2   Maija   2            4         
2   Maija   2            5         
3   Aapeli  NULL         NULL      
```

Toinen vaihe puolestaan yhdistää yllä olevan tulostaulun ja taulun `Products`:

```sql
SELECT
  *
FROM
  Customers LEFT JOIN Purchases ON Customers.id = Purchases.customer_id
            LEFT JOIN Products ON Products.id = Purchases.product_id;
```

```
id  name    customer_id  product_id  id    name      price
--  ------  -----------  ----------  ----  --------  -----
1   Uolevi  1            2           2     porkkana  5    
1   Uolevi  1            5           5     selleri   4    
2   Maija   2            1           1     retiisi   7    
2   Maija   2            4           4     lanttu    8    
2   Maija   2            5           5     selleri   4    
3   Aapeli  NULL         NULL        NULL  NULL      NULL 
```

Molemmissa vaiheissa Aapeli pääsee osaksi tulostaulua,
koska kyseinen rivi ei täsmää minkään oikean taulun rivin kanssa.
