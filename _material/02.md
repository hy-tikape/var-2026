---
title: 2. Grunderna i SQL-språket
slug: osa2
sections:
- Grundkommandon
- Yhteenveto ja ryhmittely
- SQLite-tietokanta
---

# 2. Grunderna i SQL-språket

## Grundkommandon

I detta kapitel bekantar vi oss med de vanligaste SQL-kommandona som används för att lägga till, hämta, ändra och ta bort innehåll i databasen.

### Skapa en tabell

Kommandot `CREATE TABLE` skapar en tabell med önskade kolumner. Till exempel skapar följande kommando tabellen `Products` som innehåller tre kolumner:

```sql
CREATE TABLE Products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price INTEGER
);
```

Vi kan namnge tabellen och kolumnerna med valfria namn. I denna kurs är det praxis att skriva tabellnamnet med stor begynnelsebokstav och i pluralform. Kolumnnamnen skriver vi däremot med liten begynnelsebokstav.

För varje kolumn anges förutom namnet även dess datatyp. I den här tabellen är kolumnerna `id` och `price` heltal (`INTEGER`) och kolumnen `name` är en sträng (`TEXT`). Kolumnen `id` är dessutom tabellens primärnyckel (`PRIMARY KEY`), vilket innebär att den identifierar varje rad i tabellen och gör det enkelt för oss att referera till raderna i tabellen.

{: .note-title }
Primärnyckel
<div class="note" markdown="1">
En tabells _primärnyckel_ (_primary key_) är en kolumn (eller en kombination av kolumner) som identifierar varje rad i tabellen. Primärnyckeln har alltid ett unikt värde för varje rad i tabellen. Som primärnyckel används vanligtvis ett heltalsbaserat id-nummer.

Ofta vill vi dessutom att id-numret ska ha _löpande numrering_. Det betyder att när rader läggs till i tabellen får den första raden automatiskt id-numret 1, den andra raden id-numret 2 och så vidare. Hur löpande numrering implementeras beror på databasen. I en SQLite-databas får till exempel en kolumn av datatypen `INTEGER PRIMARY KEY` automatiskt löpande numrering.
</div>

### Lägga till data

Med kommandot `INSERT` kan man lägga till en ny rad i en tabell. Till exempel lägger följande kommando till en rad i tabellen `Products` vi nyss skapade:

```sql
INSERT INTO Products (name, price) VALUES ('rädisa', 7);
```

Här anger vi värden för kolumnerna `name` och `price` i raden som ska läggas till. I och med att kolumnen id har löpande numrering får den automatiskt värdet 1 för tabellens första rad. Tabellen ser nu ut på följande sätt: 

```
id  name     price
--  -------  -----
1   rädisa   7    
```

I fall att vi inte anger ett värde för en kolumn får den ett standardvärde. Standardvärdet är vanligtvis `NULL`, vilket betyder att information saknas. Som exempel anger vi inget värde för kolumnen `price` i följande kommando:

```sql
INSERT INTO Products (name) VALUES ('rädisa');
```

Tabellen får då en rad där priset är `NULL` (alltså priset fattas):

```
id  name     price
--  -------  -----
1   rädisa   NULL 
```

### Exempeltabell

Vi antar i detta avsnitts kommande exempel att följande fem rader har lagts till i tabellen     `Products`:

```sql
INSERT INTO Products (name, price) VALUES ('rädisa', 7);
INSERT INTO Products (name, price) VALUES ('morot', 5);
INSERT INTO Products (name, price) VALUES ('rova', 4);
INSERT INTO Products (name, price) VALUES ('kålrot', 8);
INSERT INTO Products (name, price) VALUES ('selleri', 4);
```

Tabellen ser alltså ut på följande sätt:

```
id  name      price
--  --------  -----
1   rädisa    7    
2   morot     5    
3   rova      4    
4   kålrot    8    
5   selleri   4    
```

### Hämta data

Kommandot `SELECT` ställer en _fråga_ (_query_), alltså hämtar data från en tabell. Det enklaste sättet att formulera en fråga är att hämta all data från tabellen:

```sql
SELECT * FROM Products;
```

Frågan ger följande svar:

```
id  name      price
--  --------  -----
1   rädisa    7    
2   morot     5    
3   rova      4    
4   kålrot    8    
5   selleri   4    
```

I frågan anger stjärnan `*` att vi vill hämta alla kolumner. Det är också möjligt att hämta endast en del av kolumnerna genom att ange deras namn. Till exempel hämtar följande fråga bara produktnamnen:

```sql
SELECT name FROM Products;
```

Frågan ger följande svar:

```
name
--------
rädisa    
morot             
rova               
kålrot               
selleri              
```

Följande fråga hämtar produktnamnen och produktpriserna.

```sql
SELECT name, price FROM Products;
```

Frågan ger nu följande svar:

```
name      price
--------  -----
rädisa    7    
morot     5    
rova      4    
kålrot    8    
selleri   4    
```

Raderna som frågan returnerar bildar en tabell som kallas för en _resultattabell_ (_result table_). Dess kolumner och rader beror på innehållet i frågan. Till exempel skapade den föregående frågan en resultattabell med två kolumner och fem rader.

När man jobbar med databaser förekommer det alltså två typer av tabeller: dels de tabeller som finns permanent i databasen och som innehåller databasens data, och dels de tillfälliga resultattabeller som skapas av frågor och vars innehåll bygger på de permanenta tabellerna.

### Sökvillkor

Genom att lägga till villkoret `WHERE` i en `SELECT`-fråga kan vi välja endast de rader som uppfyller ett visst villkor. Till exempel hämtar följande fråga information om kålroten:

```sql
SELECT * FROM Products WHERE name = 'kålrot';
```

Frågan ger följande svar:

```
id  name    price
--  ------  -----
4   kålrot  8    
```

I villkoren kan man använda jämförelser och orden `AND` och `OR` på samma sätt som i programmering. Till exempel söker följande fråga produkter vars pris ligger mellan 4 och 6:


```sql
SELECT * FROM Products WHERE price >= 4 AND price <= 6;
```

Frågan ger följande svar:

```
id  name      price
--  --------  -----
2   morot     5    
3   rova      4    
5   selleri   4    
```

I SQL betyder operatorn `<>` "inte lika med". Till exempel hämtar följande fråga de rader där priset inte är 4:

```sql
SELECT * FROM Products WHERE price <> 4;
```

Frågan ger följande svar:

```
id  name      price
--  --------  -----
1   rädisa    7    
2   morot     5    
4   kålrot    8    
```

### Sortering

Som standard kan raderna i resultattabellen ha vilken ordning som helst. Vi kan dock ange önskad ordning med hjälp av `ORDER BY`. Till exempel hämtar följande fråga produkterna i alfabetisk ordning efter namn:

```sql
SELECT * FROM Products ORDER BY name;
```

Frågan ger följande svar:

```
id  name      price
--  --------  -----
4   kålrot    8    
3   rova      4    
2   morot     5    
1   rädisa    7    
5   selleri   4    
```

Ordningen är som standard från minst till störst. Om vi vill ha ordningen från störst till minst kan vi lägga till ordet `DESC` efter kolumnnamnet:

```sql
SELECT * FROM Products ORDER BY name DESC;
```

Frågan ger nu följande svar:

```
id  name      price
--  --------  -----
5   selleri   4    
1   rädisa    7    
2   morot     5     
3   rova      4    
4   kålrot    8    
```

I databasspråk är ordningen antingen _stigande_ (_ascending_), alltså från minst till störst, eller _fallande_ (descending), alltså från störst till minst. Som standard är ordningen stigande, och nyckelordet `DESC` betyder alltså fallande ordning.

Nyckelordet `ASC`, betyder stigande ordning. Följande frågor fungerar alltså på samma sätt:

```sql
SELECT * FROM Products ORDER BY name;
```

```sql
SELECT * FROM Products ORDER BY name ASC;
```

Nyckelordet `ASC` används sällan i praktiken.

Vi kan också ordna rader enligt flera olika kriterier. Till exempel ordnar följande fråga raderna först enligt pris från dyrast till billigast, och därefter alfabetiskt enligt namn:

```sql
SELECT * FROM Products ORDER BY price DESC, name;
```

Frågan ger följande svar:

```
id  name      price
--  --------  -----
4   kålrot    8    
1   rädisa    7    
2   morot     5    
3   rova      4    
5   selleri   4    
```

I det här fallet ordnas produkterna rova och selleri alfabetiskt enligt namn, eftersom de kostar lika mycket.

### Separata resultatrader

Ibland kan resultattabellen innehålla flera likadana rader:

```sql
SELECT price FROM Products;
```

Eftersom priset för två produkter är 4, blir innehållet i två resultatrader 4:

```
price
-----
7         
5         
4         
8         
4         
```

Om vi däremot bara vill ha unika resultatrader kan vi lägga till nyckelordet `DISTINCT` i frågan:

```sql
SELECT DISTINCT price FROM Products;
```

Frågan ger nu följande svar:

```
price
-----
7         
5         
4         
8         
```

### Begränsning av resultatrader

När vi lägger till `LIMIT x` i slutet av frågan returnerar frågan som svar endast de första `x` resultatraderna. Till exempel betyder `LIMIT 3` att frågan returnerar som svar de tre första resultatraderna.

En mer generell form är `LIMIT x OFFSET y`, vilket betyder att vi vill ha `x` rader med start från position `y` (0-indexerat). Till exempel betyder `LIMIT 3 OFFSET 1` att frågan returnerar som svar den andra, tredje och fjärde resultatraden.

Låt oss som exempel titta på en fråga som hämtar produkter från billigast till dyrast:

```sql
SELECT * FROM Products ORDER BY price;
```

Kyselyn tuloksena on seuraava tulostaulu:

```
id  name      price
--  --------  -----
3   rova      2    
5   selleri   4    
2   morot     5    
1   rädisa    7    
4   kålrot    8    
```

Saamme haettua kolme halvinta tuotetta seuraavasti:

```sql
SELECT * FROM Products ORDER BY price LIMIT 3;
```

Kyselyn tulos on seuraava:

```
id  name      price
--  --------  -----
3   nauris    2    
5   selleri   4    
2   porkkana  5    
```

Seuraava kysely puolestaan hakee kolme halvinta tuotetta toiseksi halvimmasta tuotteesta alkaen:

```sql
SELECT * FROM Products ORDER BY price LIMIT 3 OFFSET 1;
```

Tämän kyselyn tulos on seuraava:

```
id  name      price
--  --------  -----
5   selleri   4    
2   porkkana  5    
1   retiisi   7    
```

{: .note-title }
Tietokantojen erot
<div class="note" markdown="1">
Tulosrivien rajaus on esimerkki asiasta, jonka toteutus vaihtelee eri tietokannoissa. Tässä esitetty syntaksi `LIMIT x OFFSET y` toimii SQLiten lisäksi MySQL:ssä ja PostgreSQL:ssä.

SQLitessä ja MySQL:ssä on myös lyhempi syntaksi `LIMIT y, x`, jossa parametrit `x` ja `y` ovat käänteisessä järjestyksessä. Tämä syntaksi ei kuitenkaan toimi PostgreSQL:ssä.

SQL-standardiin tulosrivien rajaus tuli vasta vuonna 2008. Standardin mukainen syntaksi on `OFFSET y ROWS FETCH FIRST x ROWS ONLY`. Tämä syntaksi toimii PostgreSQL:ssä mutta ei MySQL:ssä eikä SQLitessä.

</div>

### Tiedon muuttaminen

Komento `UPDATE` muuttaa taulun rivejä, jotka täsmäävät haluttuun ehtoon. Esimerkiksi seuraava komento muuttaa tuotteen 2 hinnaksi 6:

```sql
UPDATE Products SET price = 6 WHERE id = 2;
```

Useita sarakkeita voi muuttaa yhdistämällä muutokset pilkuilla. Esimerkiksi seuraava komento muuttaa tuotteen 2 nimeksi ananas ja hinnaksi 6:

```sql
UPDATE Products SET name = 'ananas', price = 6 WHERE id = 2;
```

Jos komennossa ei ole ehtoa, muutos vaikuttaa _kaikkiin_ riveihin. Esimerkiksi seuraava komento muuttaa jokaisen tuotteen hinnaksi 1:

```sql
UPDATE Products SET price = 1;
```

### Tiedon poistaminen

Komento `DELETE` poistaa taulusta rivit, jotka täsmäävät annettuun ehtoon. Esimerkiksi seuraava komento poistaa taulusta tuotteen 5:

```sql
DELETE FROM Products WHERE id = 5;
```

Kuten muuttamisessa, jos ehtoa ei ole, niin komento vaikuttaa kaikkiin riveihin. Seuraava komento siis poistaa _kaikki_ tuotteet taulusta:

```sql
DELETE FROM Products;
```

Komento `DROP TABLE` poistaa tietokannan taulun (ja kaiken sen sisällön). Esimerkiksi seuraava komento poistaa taulun `Products`:

```sql
DROP TABLE Products;
```

### Kommentit

Merkintä `--` aloittaa rivin loppuun päättyvän kommentin:

```sql
CREATE TABLE Products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price INTEGER -- price in euros
)
```

Toinen tapa on aloittaa kommentti `/*` ja lopettaa `*/`:

```sql
CREATE TABLE Products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price INTEGER /* price in euros */
)
```

## Yhteenveto ja ryhmittely

Yhteenvetokysely antaa tuloksena jonkin yksittäisen arvon taulun riveistä, kuten taulun rivien määrän tai sarakkeen kaikkien arvojen summan. Tällaisen kyselyn tulostaulussa on vain yksi rivi.

Yhteenvetokyselyn perustana on _koostefunktio_ (_aggregate function_), joka laskee yhteenvetoarvon taulun riveistä. Tavallisimmat koostefunktiot ovat seuraavat:

* `COUNT()`: rivien määrä
* `SUM()`: arvojen summa
* `MIN()`: pienin arvo
* `MAX()`: suurin arvo
* `AVG()`: arvojen keskiarvo

### Esimerkkejä

Tarkastellaan taas taulua `Products`:

```
id  name      price
--  --------  -----
1   retiisi   7    
2   porkkana  5    
3   nauris    4    
4   lanttu    8    
5   selleri   4    
```

Seuraava kysely hakee taulun rivien määrän:

```sql
SELECT COUNT(*) FROM Products;
```

```
COUNT(*)
--------
5
```

Seuraava kysely hakee niiden rivien määrän, joissa hinta on 4:

```sql
SELECT COUNT(*) FROM Products WHERE price = 4;
```

```
COUNT(*)
--------
2
```

Seuraava kysely hakee summan tuotteiden hinnoista:

```sql
SELECT SUM(price) FROM Products;
```

```
SUM(price)
----------
28
```

Tässä tapauksessa kyselyn tuloksena on 7 + 5 + 4 + 8 + 4 = 28.

Seuraava kysely hakee pienimmän ja suurimman hinnan:

```sql
SELECT MIN(price), MAX(price) FROM Products;
```

```
MIN(price)  MAX(price)
----------  ----------
4           8
```

### Lisää COUNT-funktiosta

Jos `COUNT`-funktion sisällä on tähti `*`, kysely laskee kaikki rivit. Jos taas funktion sisällä on sarakkeen nimi, kysely laskee rivit, joissa sarakkeessa on jokin arvo eli sarakkeen arvo ei ole `NULL`.

Tarkastellaan esimerkkinä seuraavaa taulua, jossa rivillä 3 ei ole hintaa:

```
id  name     price
--  -------  -----
1   retiisi  7    
2   nauris   4    
3   lanttu   NULL 
4   selleri  4    
```

Seuraava kysely hakee rivien yhteismäärän:

```sql
SELECT COUNT(*) FROM Products;
```

```
COUNT(*)  
--------
4
```

Seuraava kysely taas hakee niiden rivien määrän, joilla on hinta:

```sql
SELECT COUNT(price) FROM Products;
```

```
COUNT(price)
------------
3
```

Voimme myös käyttää sanaa `DISTINCT`, jotta saamme laskettua, montako eri arvoa jossakin sarakkeessa on:

```sql
SELECT COUNT(DISTINCT price) FROM Products;
```

```
COUNT(DISTINCT price)
---------------------
2
```

Tämän kyselyn tuloksena on 2, koska sarakkeessa `price` on kaksi eri arvoa (4 ja 7). Tähän ei lasketa mukaan `NULL`-arvoa.

### Tyhjän aineiston käsittely

Koostefunktioiden toiminta saattaa aiheuttaa yllätyksiä, jos käsiteltävässä aineistossa ei ole yhtään riviä.
Tarkastellaan esimerkkinä seuraavaa tyhjää taulua:

```
id  name     price
--  -------  -----
```

Funktio `COUNT` antaa rivien määräksi 0:

```sql
SELECT COUNT(price) FROM Products;
```

```
COUNT(price)
------------
0
```

Sen sijaan funktio `SUM` antaa summaksi `NULL`:

```sql
SELECT SUM(price) FROM Products;
```

```
SUM(price)
----------
NULL
```

Tämä voi tuntua yllättävältä, koska tyhjän summan voisi olettaa olevan 0 eikä `NULL`. Vastaavasti myös `MIN`, `MAX` ja `AVG` antavat tuloksen `NULL` tyhjälle aineistolle.

Funktion `IFNULL` avulla voi varautua tilanteeseen, jossa koostefunktio saattaa antaa tuloksen `NULL`. Seuraavassa kyselyssä `IFNULL(SUM(price), 0)` tarkoittaa muuten samaa kuin `SUM(price)`, mutta tulos `NULL` muutetaan tulokseksi 0.

```sql
SELECT IFNULL(SUM(price), 0) FROM Products;
```

```
IFNULL(SUM(price), 0)
---------------------´
0
```

{: .note-title }
NULL-arvojen käsittely
<div class="note" markdown="1">
Funktio `IFNULL(x, y)` palauttaa arvon `x`, jos `x` ei ole `NULL`, ja muuten arvon `y`. Tämän avulla voidaan käsitellä tilanne, jossa SQL-kyselyssä oleva arvo saattaa olla `NULL`. Esimerkiksi `IFNULL(x, 0)` muuttaa arvon `x` nollaksi, jos se on `NULL`.

Funktio `IFNULL` ei kuulu SQL-standardiin, eikä se toimi kaikissa tietokannoissa. SQL-standardin mukainen funktio on `COALESCE`, jota voi käyttää samalla tavalla. Esimerkiksi `COALESCE(x, 0)` tarkoittaa samaa kuin `IFNULL(x, 0)`.

Palaamme `NULL`-arvojen käsittelyyn tarkemmin myöhemmin.
</div>

### Ryhmittely

Ryhmittelyn avulla voimme yhdistää rivikohtaista ja koostefunktion antamaa tietoa. Ideana on, että rivit jaetaan ryhmiin `GROUP BY` -osassa annettujen sarakkeiden mukaan ja tämän jälkeen koostefunktion arvo lasketaan jokaiselle ryhmälle erikseen.

Tarkastellaan esimerkkinä seuraavaa taulua `Employees`:

```
id  name      company   salary
--  --------  --------  ------
1   Anna      Google    8000  
2   Liisa     Google    7500  
3   Kaaleppi  Amazon    5000  
4   Uolevi    Amazon    8000  
5   Maija     Google    9500  
6   Vihtori   Facebook  5000  
```

Seuraava kysely hakee kunkin yrityksen työntekijöiden määrän:

```sql
SELECT company, COUNT(*) FROM Employees GROUP BY company;
```

Kyselyn tulos on seuraava:

```
company   COUNT(*)
--------  --------
Amazon    2       
Facebook  1       
Google    3       
```

Tämä tarkoittaa, että Amazonilla on 2 työntekijää, Facebookilla on 1 työntekijä ja Googlella on 3 työntekijää.

### Miten ryhmittely toimii?

Ryhmittelyssä jokainen ryhmä sisältää kaikki rivit, joissa on sama sisältö ryhmittelyssä käytetyissä sarakkeissa. Ryhmittely tuottaa tulostaulun, jonka rivien määrä on sama kuin ryhmien määrä. Jokaisella rivillä voi esiintyä ryhmittelyssä käytettyjä sarakkeita sekä koostefunktioita.

Äskeisessä kyselyssä ryhmittelyn ehtona on `GROUP BY company`, joten rivit jaetaan ryhmiin sarakkeen `company` mukaan. Tässä tapauksessa ryhmät ovat:

**Ryhmä 1**:

```
id  name      company  salary
--  --------  -------  ------
3   Kaaleppi  Amazon   5000  
4   Uolevi    Amazon   8000  
```

**Ryhmä 2**:

```
id  name     company   salary
--  -------  --------  ------
6   Vihtori  Facebook  5000  
```

**Ryhmä 3**:

```
id  name   company  salary
--  -----  -------  ------
1   Anna   Google   8000  
2   Liisa  Google   7500  
5   Maija  Google   9500  
```

Tämän jälkeen jokaiselle ryhmälle lasketaan rivien määrä funktiolla `COUNT(*)`.

### Ryhmittelyn sarakkeet

Melko usein ryhmittelyn perusteena on tasan yksi sarake, kuten sarake `company` äskeisessä esimerkissä. Jos ryhmittelyssä on useampi sarake, jokainen ryhmä muodostuu riveistä, joilla on sama arvoyhdistelmä ryhmittelyyn kuuluvissa sarakkeissa.

Esimerkiksi seuraavassa kyselyssä ryhmittelyn perusteena on kaksi saraketta:

```sql
SELECT company, salary, COUNT(*) FROM Employees GROUP BY company, salary;
```

Koska jokaisella rivillä on eri arvoyhdistelmä näissä sarakkeissa, tulostaulussa jokainen rivi on omassa ryhmässään:

```
company   salary  COUNT(*)
--------  ------  --------
Amazon    5000    1       
Amazon    8000    1       
Facebook  5000    1       
Google    7500    1       
Google    8000    1       
Google    9500    1       
```

Ryhmittelyn jälkeen tulostaulussa voi olla ryhmittelyyn kuuluvia sarakkeita mutta ei ryhmittelyn ulkopuolisia sarakkeita. Esimerkiksi seuraava kysely ei olisi mielekäs:

```sql
SELECT company, name FROM Employees GROUP BY company;
```

Tässä sarake `name` ei kuulu ryhmittelyyn, minkä takia olisi epäselvää, mikä sarakkeen arvoksi tulisi tulostaulussa. Esimerkiksi tulostauluun tulee vain yksi rivi, joka liittyy yritykseen Amazon, mutta yrityksellä on kaksi työntekijää, joilla on eri nimet (Kaaleppi ja Uolevi).

{: .note-title }
Ryhmittely SQLitessä
<div class="note" markdown="1">
Huomaa, että SQLite sallii äskeisen kyselyn, jossa haetaan ryhmittelyn ulkopuolinen sarake:

```sql
SELECT company, name FROM Employees GROUP BY company;
```

```
company   name   
--------  -------
Amazon    Uolevi 
Facebook  Vihtori
Google    Maija  
```

Koska sarake `name` ei kuulu ryhmittelyyn, sillä voi olla useita arvoja ryhmässä ja tulostauluun tulee yksi niistä jollain logiikalla valittuna. Tällainen kysely ei kuitenkaan yleensä toimi muissa tietokannoissa.
</div>

### Lisää kyselyjä

Seuraava kysely hakee joka yrityksestä palkkojen summan:

```sql
SELECT company, SUM(salary) FROM Employees GROUP BY company;
```

```
company   SUM(salary)
--------  -----------
Amazon    13000      
Facebook  5000       
Google    25000      
```

Tässä Amazonin palkkojen summa on 5000 + 8000 = 13000, Facebookin palkkojen summa on 5000 ja Googlen palkkojen summa on 8000 + 7500 + 9500 = 25000.

Seuraava kysely puolestaan hakee korkeimman palkan:

```sql
SELECT company, MAX(salary) FROM Employees GROUP BY company;
```

```
company   MAX(salary)
--------  -----------
Amazon    8000       
Facebook  5000       
Google    9500       
```

Tässä Amazonin suurin palkka on 8000, Facebookin suurin palkka on 5000 ja Googlen suurin palkka on 9500.

### Tulossarakkeen nimentä

Oletuksena tulostaulun sarake saa nimen suoraan kyselyn perusteella, mutta voimme halutessamme antaa myös oman nimen `AS`-sanan avulla. Tämän ansiosta voimme esimerkiksi selventää, mistä yhteenvetokyselyssä on kyse.

Esimerkiksi seuraavassa kyselyssä toisen sarakkeen nimeksi tulee `max_salary`:

```sql
SELECT
  company, MAX(salary) AS max_salary
FROM
  Employees
GROUP BY
  company;
```

```
company   max_salary
--------  ----------
Amazon    8000      
Facebook  5000      
Google    9500      
```

Itse asiassa sana `AS` ei ole pakollinen, eli voimme kirjoittaa kyselyn myös näin:

```sql
SELECT
  company, MAX(salary) max_salary
FROM
  Employees
GROUP BY
  company;
```

### Rajaus ryhmittelyn jälkeen

Voimme lisätä kyselyyn myös `HAVING`-osan, joka rajaa tuloksia ryhmittelyn jälkeen. Esimerkiksi seuraava kysely hakee yritykset, joissa on ainakin kaksi työntekijää:

```sql
SELECT
  company, COUNT(*)
FROM
  Employees
GROUP BY
  company
HAVING
  COUNT(*) >= 2;
```

```
company  COUNT(*)
-------  --------
Amazon   2       
Google   3       
```

Voimme myös käyttää koostefunktiota vain `HAVING`-osassa:

```sql
SELECT
  company
FROM
  Employees
GROUP BY
  company
HAVING
  COUNT(*) >= 2;
```

```
company
-------
Amazon    
Google    
```

### Kyselyn yleiskuva

SQL-kyselyn yleiskuva on seuraava:

`SELECT` – `FROM` – `WHERE` – `GROUP BY` – `HAVING` – `ORDER BY` – `LIMIT`

Kyselystä riippuu, mitkä näistä osista siinä esiintyvät. Tämä on kuitenkin aina järjestys,
jossa kyselyn osat sijaitsevat toisiinsa nähden.

Tarkastellaan seuraavaksi esimerkkiä kyselystä, joka sisältää yhtä aikaa kaikki yllä mainitut osat. Kysely suoritetaan tauluun `Tasks`, jossa on projekteihin liittyviä tehtäviä. Jokaisella tehtävällä on tietty prioriteetti. Tehtävä on _kriittinen_, jos sen prioriteetti on ainakin 3.

```
id  project_id  priority
--  ----------  --------
1   1           3       
2   1           4       
3   1           4       
4   2           1       
5   2           5       
6   3           2       
7   3           4       
8   3           5       
```

Seuraava kysely etsii projektit, joissa on vähintään kaksi kriittistä tehtävää. Kysely järjestää tulokset projektin id-numeron mukaan ja antaa 10 ensimmäistä tulosta.

```sql
SELECT
  project_id, COUNT(*)
FROM
  Tasks
WHERE
  priority >= 3
GROUP BY
  project_id
HAVING
  COUNT(*) >= 2
ORDER BY
  project_id
LIMIT
  10;
```

Kyselyn tulos on tässä:

```
project_id  COUNT(*)
----------  --------
1           3       
3           2       
```

Tämä tarkoittaa, että projektissa 1 on kolme kriittistä tehtävää ja projektissa 3 on kaksi kriittistä tehtävää.

Katsotaan nyt tarkemmin, miten kysely toimii. Kyselyn lähtökohtana ovat kaikki taulussa `Tasks` olevat rivit. Ehto `WHERE priority >= 3` valitsee käsittelyyn kriittiset tehtävät:

```
id  project_id  priority
--  ----------  --------
1   1           3       
2   1           4       
3   1           4       
5   2           5       
7   3           4       
8   3           5       
```

Kyselyn ryhmittely `GROUP BY project_id` jakaa rivit ryhmiin näin:

**Ryhmä 1:**

```
id  project_id  priority
--  ----------  --------
1   1           3       
2   1           4       
3   1           4       
```

**Ryhmä 2:**

```
id  project_id  priority
--  ----------  --------
5   2           5       
```

**Ryhmä 3:**

```
id  project_id  priority
--  ----------  --------
7   3           4       
8   3           5       
```

Osa `HAVING COUNT(*) >= 2` valitsee tulostauluun ryhmät, joissa on ainakin kaksi riviä. Tässä tapauksessa valitaan ryhmät 1 ja 3.

Tulostaulussa on joka ryhmästä sarake `project_id` sekä funktion `COUNT(*)` antama tulos eli ryhmän rivien määrä. Tässä tapauksessa projektissa 1 on kolme tärkeää tehtävää ja projektissa 3 on kaksi tärkeää tehtävää.

Osa `ORDER BY project_id` järjestää tulostaulun rivit projektin id-numeron mukaan. Tässä tapauksessa projektit ovat 1 ja 3. Osa `LIMIT 10` ei vaikuta tässä tapauksessa, koska tulostaulussa on muutenkin alle 10 riviä.

Kysely tuottaa seuraavan tulostaulun:

```
project_id  COUNT(*)
----------  --------
1           3       
3           2       
```

## SQLite-tietokanta

[SQLite](https://www.sqlite.org/) on yksinkertainen avoimesti saatavilla oleva tietokantajärjestelmä, joka soveltuu hyvin SQL-kielen opetteluun. Voit kokeilla helposti SQL-kieleen liittyviä asioita SQLiten avulla,
ja käytämme sitä tämän kurssin harjoituksissa.

SQLite on mainio valinta SQL-kielen harjoitteluun, mutta siinä on tiettyjä rajoituksia, jotka voivat aiheuttaa ongelmia todellisissa sovelluksissa. Muita suosittuja avoimesti saatavilla olevia tietokantajärjestelmiä ovat [MySQL](https://www.mysql.com/) ja [PostgreSQL](https://www.postgresql.org/). Niissä on suuri määrä ominaisuuksia, jotka puuttuvat SQLitestä, mutta toisaalta niiden asentaminen ja käyttäminen on vaikeampaa.

Eri tietokantajärjestelmien välillä siirtyminen on onneksi helppoa, koska kaikissa on samantapainen SQL-kieli.

### SQLite-tulkki

SQLite-tulkki on ohjelma, jonka kautta voidaan käyttää SQLite-tietokantaa. Tulkki käynnistyy antamalla komentorivillä komento `sqlite3`. Tämän jälkeen tulkkiin voi kirjoittaa joko suoritettavia SQL-komentoja tai pisteellä alkavia tulkin omia komentoja.

SQLite-tulkin asentaminen riippuu käyttöjärjestelmästä:

* Jos käytät Linuxia, voit asentaa SQLiten paketinhallinnan kautta.
* Jos käytät Macia, SQLite on luultavasti valmiiksi asennettuna koneellasi.
* Jos käytät Windowsia, voit hakea [SQLiten lataussivulta](https://www.sqlite.org/download.html) paketin, jonka vieressä on otsikko _command-line tools_ (eli komentorivityökalut). Tarvittava tiedosto on se, jonka nimi alkaa `sqlite3`.

([Video: SQLiten asennus ja käyttö Windowsissa](https://www.youtube.com/watch?v=UVfvI6FYtbc))

### Esimerkki

SQLite-tulkissa tietokanta on oletuksena muistissa (_in-memory database_), jolloin se on aluksi tyhjä ja katoaa, kun tulkki suljetaan. Tämä on hyvä tapa testailla SQL-kielen ominaisuuksia. Keskustelu tulkin kanssa voi näyttää vaikkapa tältä:

```console?lang=sqlite
$ sqlite3
SQLite version 3.31.1 2020-01-27 19:55:54
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite> CREATE TABLE Products (id INTEGER PRIMARY KEY,
   ...>                        name TEXT, price INTEGER);
sqlite> .tables
Products
sqlite> INSERT INTO Products (name, price) VALUES ('retiisi', 7);
sqlite> INSERT INTO Products (name, price) VALUES ('porkkana', 5);
sqlite> INSERT INTO Products (name, price) VALUES ('nauris', 4);
sqlite> INSERT INTO Products (name, price) VALUES ('lanttu', 8);
sqlite> INSERT INTO Products (name, price) VALUES ('selleri', 4);
sqlite> SELECT * FROM Products;
1|retiisi|7
2|porkkana|5
3|nauris|4
4|lanttu|8
5|selleri|4
sqlite> .mode column
sqlite> .headers on
sqlite> SELECT * FROM Products;
id  name      price
--  --------  -----
1   retiisi   7    
2   porkkana  5    
3   nauris    4    
4   lanttu    8    
5   selleri   4    
sqlite> .quit
```

Esimerkissä luodaan aluksi taulu `Products` ja tarkastetaan sitten tulkin komennolla `.tables`, mitä tauluja tietokannassa on. Ainoa taulu on `Products`, mikä kuuluu asiaan, koska tietokanta on alussa tyhjä.

Sitten tauluun lisätään rivejä, minkä jälkeen rivit haetaan taulusta. SQLite-tulkin oletustapa näyttää tulosrivit pystyviivoin erotettuina voi olla vaikea lukea, mutta tulostusta voi parantaa tulkin komennoilla `.mode column` (jokaisella sarakkeella on kiinteä leveys) ja `.headers on` (sarakkeiden nimet näytetään).

Lopuksi suoritetaan tulkin komento `.quit`, joka sulkee tulkin.

### Tietokanta tiedostossa

Käynnistyksen yhteydessä SQLite-tulkille voi antaa parametrina tiedoston, johon tietokanta tallennetaan. Tällöin tietokannan sisältö säilyy tallessa tulkin sulkemisen jälkeen.

Seuraavassa esimerkissä tietokanta tallennetaan tiedostoon `test.db`. Tämän ansiosta tietokannan sisältö on edelleen tallessa, kun tulkki käynnistetään uudestaan.

```console?lang=sqlite
$ sqlite3 test.db
SQLite version 3.31.1 2020-01-27 19:55:54
Enter ".help" for usage hints.
sqlite> CREATE TABLE Products (id INTEGER PRIMARY KEY,
   ...>                        name TEXT, price INTEGER);
sqlite> .tables
Products
sqlite> .quit
$ sqlite3 test.db
SQLite version 3.31.1 2020-01-27 19:55:54
Enter ".help" for usage hints.
sqlite> .tables
Products
sqlite> .quit
```

### Komennot tiedostosta

Voimme myös ohjata SQLite-tulkille tiedoston, jossa olevat komennot suoritetaan peräkkäin. Tämän avulla voimme automatisoida komentojen suorittamista. Esimerkiksi voimme laatia seuraavan tiedoston `commands.sql`:

{: .code-title }
commands.sql
```
CREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER);
INSERT INTO Products (name, price) VALUES ('retiisi', 7);
INSERT INTO Products (name, price) VALUES ('porkkana', 5);
INSERT INTO Products (name, price) VALUES ('nauris', 4);
INSERT INTO Products (name, price) VALUES ('lanttu', 8);
INSERT INTO Products (name, price) VALUES ('selleri', 4);
.mode column
.headers on
SELECT * FROM Products;
```

Tämän jälkeen voimme ohjata komennot tiedostosta tulkille näin:

```console?lang=sqlite
$ sqlite3 < commands.sql
id  name      price
--  --------  -----
1   retiisi   7    
2   porkkana  5    
3   nauris    4    
4   lanttu    8    
5   selleri   4    
```
