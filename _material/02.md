---
title: 2. Grunderna i SQL-språket
slug: osa2
sections:
- Grundkommandon
- Yhteenveto ja ryhmittely
- SQLite-tietokanta
---

# 2. Grunderna i SQL-språket

## Grundkommandon

I detta kapitel bekantar vi oss med de vanligaste SQL-kommandona som används för att lägga till, hämta, ändra och ta bort innehåll i databasen.

### Skapa en tabell

Kommandot `CREATE TABLE` skapar en tabell med önskade kolumner. Till exempel skapar följande kommando tabellen `Products` som innehåller tre kolumner:

```sql
CREATE TABLE Products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price INTEGER
);
```

Vi kan namnge tabellen och kolumnerna med valfria namn. I denna kurs är det praxis att skriva tabellnamnet med stor begynnelsebokstav och i pluralform. Kolumnnamnen skriver vi däremot med liten begynnelsebokstav.

För varje kolumn anges förutom namnet även dess datatyp. I den här tabellen är kolumnerna `id` och `price` heltal (`INTEGER`) och kolumnen `name` är en sträng (`TEXT`). Kolumnen `id` är dessutom tabellens primärnyckel (`PRIMARY KEY`), vilket innebär att den identifierar varje rad i tabellen och gör det enkelt för oss att referera till raderna i tabellen.

{: .note-title }
Primärnyckel
<div class="note" markdown="1">
En tabells _primärnyckel_ (_primary key_) är en kolumn (eller en kombination av kolumner) som identifierar varje rad i tabellen. Primärnyckeln har alltid ett unikt värde för varje rad i tabellen. Som primärnyckel används vanligtvis ett heltalsbaserat id-nummer.

Ofta vill vi dessutom att id-numret ska ha _löpande numrering_. Det betyder att när rader läggs till i tabellen får den första raden automatiskt id-numret 1, den andra raden id-numret 2 och så vidare. Hur löpande numrering implementeras beror på databasen. I en SQLite-databas får till exempel en kolumn av datatypen `INTEGER PRIMARY KEY` automatiskt löpande numrering.
</div>

### Lägg till data

Med kommandot `INSERT` kan man lägga till en ny rad i en tabell. Till exempel lägger följande kommando till en rad i tabellen `Products` vi nyss skapade:

```sql
INSERT INTO Products (name, price) VALUES ('rädisa', 7);
```

Här anger vi värden för kolumnerna `name` och `price` i raden som ska läggas till. I och med att kolumnen id har löpande numrering får den automatiskt värdet 1 för tabellens första rad. Tabellen ser nu ut på följande sätt: 

```
id  name     price
--  -------  -----
1   rädisa   7    
```

I fall att vi inte anger ett värde för en kolumn får den ett standardvärde. Standardvärdet är vanligtvis `NULL`, vilket betyder att information saknas. Som exempel anger vi inget värde för kolumnen `price` i följande kommando:

```sql
INSERT INTO Products (name) VALUES ('rädisa');
```

Tabellen får då en rad där priset är `NULL` (alltså priset fattas):

```
id  name     price
--  -------  -----
1   rädisa   NULL 
```

### Exempeltabell

Vi antar i detta avsnitts kommande exempel att följande fem rader har lagts till i tabellen     `Products`:

```sql
INSERT INTO Products (name, price) VALUES ('rädisa', 7);
INSERT INTO Products (name, price) VALUES ('morot', 5);
INSERT INTO Products (name, price) VALUES ('rova', 4);
INSERT INTO Products (name, price) VALUES ('kålrot', 8);
INSERT INTO Products (name, price) VALUES ('selleri', 4);
```

Tabellen ser alltså ut på följande sätt:

```
id  name      price
--  --------  -----
1   rädisa    7    
2   morot     5    
3   rova      4    
4   kålrot    8    
5   selleri   4    
```

### Hämta data

Kommandot `SELECT` ställer en _fråga_ (_query_), alltså hämtar data från en tabell. Det enklaste sättet att formulera en fråga är att hämta all data från tabellen:

```sql
SELECT * FROM Products;
```

Frågan ger följande svar:

```
id  name      price
--  --------  -----
1   rädisa    7    
2   morot     5    
3   rova      4    
4   kålrot    8    
5   selleri   4    
```

I frågan anger stjärnan `*` att vi vill hämta alla kolumner. Det är också möjligt att hämta endast en del av kolumnerna genom att ange deras namn. Till exempel hämtar följande fråga bara produktnamnen:

```sql
SELECT name FROM Products;
```

Frågan ger följande svar:

```
name
--------
rädisa    
morot             
rova               
kålrot               
selleri              
```

Följande fråga hämtar produktnamnen och produktpriserna.

```sql
SELECT name, price FROM Products;
```

Frågan ger nu följande svar:

```
name      price
--------  -----
rädisa    7    
morot     5    
rova      4    
kålrot    8    
selleri   4    
```

Raderna som frågan returnerar bildar en tabell som kallas för en _resultattabell_ (_result table_). Dess kolumner och rader beror på innehållet i frågan. Till exempel skapade den föregående frågan en resultattabell med två kolumner och fem rader.

När man jobbar med databaser förekommer det alltså två typer av tabeller: dels de tabeller som finns permanent i databasen och som innehåller databasens data, och dels de tillfälliga resultattabeller som skapas av frågor och vars innehåll bygger på de permanenta tabellerna.

### Sökvillkor

Genom att lägga till villkoret `WHERE` i en `SELECT`-fråga kan vi välja endast de rader som uppfyller ett visst villkor. Till exempel hämtar följande fråga information om kålroten:

```sql
SELECT * FROM Products WHERE name = 'kålrot';
```

Frågan ger följande svar:

```
id  name    price
--  ------  -----
4   kålrot  8    
```

I villkoren kan man använda jämförelser och orden `AND` och `OR` på samma sätt som i programmering. Till exempel söker följande fråga produkter vars pris ligger mellan 4 och 6:


```sql
SELECT * FROM Products WHERE price >= 4 AND price <= 6;
```

Frågan ger följande svar:

```
id  name      price
--  --------  -----
2   morot     5    
3   rova      4    
5   selleri   4    
```

I SQL betyder operatorn `<>` "inte lika med". Till exempel hämtar följande fråga de rader där priset inte är 4:

```sql
SELECT * FROM Products WHERE price <> 4;
```

Frågan ger följande svar:

```
id  name      price
--  --------  -----
1   rädisa    7    
2   morot     5    
4   kålrot    8    
```

### Sortering

Som standard kan raderna i resultattabellen ha vilken ordning som helst. Vi kan dock ange önskad ordning med hjälp av `ORDER BY`. Till exempel hämtar följande fråga produkterna i alfabetisk ordning efter namn:

```sql
SELECT * FROM Products ORDER BY name;
```

Frågan ger följande svar:

```
id  name      price
--  --------  -----
4   kålrot    8    
3   rova      4    
2   morot     5    
1   rädisa    7    
5   selleri   4    
```

Ordningen är som standard från minst till störst. Om vi vill ha ordningen från störst till minst kan vi lägga till ordet `DESC` efter kolumnnamnet:

```sql
SELECT * FROM Products ORDER BY name DESC;
```

Frågan ger nu följande svar:

```
id  name      price
--  --------  -----
5   selleri   4    
1   rädisa    7    
2   morot     5     
3   rova      4    
4   kålrot    8    
```

I databasspråk är ordningen antingen _stigande_ (_ascending_), alltså från minst till störst, eller _fallande_ (descending), alltså från störst till minst. Som standard är ordningen stigande, och nyckelordet `DESC` betyder alltså fallande ordning.

Nyckelordet `ASC`, betyder stigande ordning. Följande frågor fungerar alltså på samma sätt:

```sql
SELECT * FROM Products ORDER BY name;
```

```sql
SELECT * FROM Products ORDER BY name ASC;
```

Nyckelordet `ASC` används sällan i praktiken.

Vi kan också ordna rader enligt flera olika kriterier. Till exempel ordnar följande fråga raderna först enligt pris från dyrast till billigast, och därefter alfabetiskt enligt namn:

```sql
SELECT * FROM Products ORDER BY price DESC, name;
```

Frågan ger följande svar:

```
id  name      price
--  --------  -----
4   kålrot    8    
1   rädisa    7    
2   morot     5    
3   rova      4    
5   selleri   4    
```

I det här fallet ordnas produkterna rova och selleri alfabetiskt enligt namn, eftersom de kostar lika mycket.

### Separata resultatrader

Ibland kan resultattabellen innehålla flera likadana rader:

```sql
SELECT price FROM Products;
```

Eftersom priset för två produkter är 4, blir innehållet i två resultatrader 4:

```
price
-----
7         
5         
4         
8         
4         
```

Om vi däremot bara vill ha unika resultatrader kan vi lägga till nyckelordet `DISTINCT` i frågan:

```sql
SELECT DISTINCT price FROM Products;
```

Frågan ger nu följande svar:

```
price
-----
7         
5         
4         
8         
```

### Begränsning av resultatrader

När vi lägger till `LIMIT x` i slutet av frågan returnerar frågan som svar endast de första `x` resultatraderna. Till exempel betyder `LIMIT 3` att frågan returnerar som svar de tre första resultatraderna.

En mer generell form är `LIMIT x OFFSET y`, vilket betyder att vi vill ha `x` rader med start från position `y` (0-indexerat). Till exempel betyder `LIMIT 3 OFFSET 1` att frågan returnerar som svar den andra, tredje och fjärde resultatraden.

Låt oss som exempel titta på en fråga som hämtar produkterna från den billigaste till den dyraste:

```sql
SELECT * FROM Products ORDER BY price;
```

Frågan ger följande resultattabell som svar:

```
id  name      price
--  --------  -----
3   rova      2    
5   selleri   4    
2   morot     5    
1   rädisa    7    
4   kålrot    8    
```

Vi kan hämta de tre billigaste produkterna på följande sätt:

```sql
SELECT * FROM Products ORDER BY price LIMIT 3;
```
Frågan ger följande svar:

```
id  name      price
--  --------  -----
3   rova      2    
5   selleri   4    
2   morot     5    
```

Följande fråga hämtar de tre billigaste produkterna med start från den näst billigaste produkten:

```sql
SELECT * FROM Products ORDER BY price LIMIT 3 OFFSET 1;
```

Frågan ger följande svar:

```
id  name      price
--  --------  -----
5   selleri   4    
2   morot     5    
1   rädisa    7    
```

{: .note-title }
Skillnader mellan databaser
<div class="note" markdown="1">
Begränsning av resultatrader är ett exempel på något som implementeras olika i olika databaser. Den syntax som visas här, `LIMIT x OFFSET y`, fungerar förutom i SQLite även i MySQL och PostgreSQL.

I SQLite och MySQL finns också en kortare syntax, `LIMIT y, x,` där parametrarna `x` och `y` kommer i omvänd ordning. Denna kortare syntax fungerar inte i PostgreSQL.

Möjligheten att begränsa resultatrader kom in i SQL-standarden först år 2008. Den standardenliga syntaxen är `OFFSET y ROWS FETCH FIRST x ROWS ONLY`. Den här syntaxen fungerar i PostgreSQL men inte i MySQL eller SQLite.

</div>

### Ändra data

Kommandot `UPDATE` ändrar de rader i en tabell som matchar det önskade villkoret. Till exempel ändrar följande kommando priset på produkt 2 till 6:

```sql
UPDATE Products SET price = 6 WHERE id = 2;
```

Flera kolumner kan ändras samtidigt genom att kombinera ändringarna med kommatecken. Till exempel ändrar följande kommando namnet på produkt 2 till ananas och priset till 6:

```sql
UPDATE Products SET name = 'ananas', price = 6 WHERE id = 2;
```

Om kommandot inte innehåller något villkor påverkar ändringen _alla rader_. Till exempel ändrar följande kommando priset på varje produkt till 1:

```sql
UPDATE Products SET price = 1;
```

### Ta bort data

Kommandot `DELETE` tar bort de rader i en tabell som matchar det givna villkoret. Till exempel tar följande kommando bort produkt 5 från tabellen:


```sql
DELETE FROM Products WHERE id = 5;
```

På samma sätt som när man ändrar data, om det inte finns något villkor, påverkar kommandot alla rader. Följande kommando tar alltså bort _alla_ produkter från tabellen:

```sql
DELETE FROM Products;
```

Kommandot `DROP TABLE` tar bort en tabell från databasen (och allt dess innehåll). Till exempel tar följande kommando bort tabellen `Products`:

```sql
DROP TABLE Products;
```

### Kommentarer

Tecknet `--` används för att skriva en kommentar som sträcker sig till slutet av raden:

```sql
CREATE TABLE Products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price INTEGER -- price in euros
)
```

Ett annat sätt är att börja kommentaren med `/*` och avsluta den med `*/`:

```sql
CREATE TABLE Products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price INTEGER /* price in euros */
)
```

## Sammanfattning och gruppering

En sammanfattningsfråga returnerar ett enskilt värde från raderna i en tabell, till exempel antalet rader i tabellen eller summan av alla värden i en kolumn. Resultattabellen för en sådan fråga innehåller endast en rad.

Grunden för en sammanfattningsfråga är en _aggregeringsfunktion_ (_aggregate function_) som beräknar ett sammanfattande värde från tabellens rader. De vanligaste aggregeringsfunktionerna är:

* `COUNT()`: antal rader
* `SUM()`: summan av värdena
* `MIN()`: minsta värdet
* `MAX()`: största värdet
* `AVG()`: medelvärdet av värdena

### Exempel

Låt oss titta på tabellen `Products`:

```
id  name      price
--  --------  -----
1   rädisa    7    
2   morot     5    
3   rova      4    
4   kålrot    8    
5   selleri   4    
```

Följande fråga hämtar antalet rader i tabellen:

```sql
SELECT COUNT(*) FROM Products;
```

```
COUNT(*)
--------
5
```

Följande fråga hämtar antalet rader där priset är 4:

```sql
SELECT COUNT(*) FROM Products WHERE price = 4;
```

```
COUNT(*)
--------
2
```

Följande fråga hämtar summan av produkternas priser:

```sql
SELECT SUM(price) FROM Products;
```

```
SUM(price)
----------
28
```

I det här fallet är svaret på frågan 7 + 5 + 4 + 8 + 4 = 28.

Följande fråga hämtar det lägsta och det högsta priset:

```sql
SELECT MIN(price), MAX(price) FROM Products;
```

```
MIN(price)  MAX(price)
----------  ----------
4           8
```

### Mer om COUNT-funktionen

Om `COUNT`-funktionen innehåller stjärnan `*`, räknar frågan alla rader. Om funktionen däremot innehåller ett kolumnnamn, räknar frågan de rader där kolumnen har ett värde, det vill säga där kolumnvärdet inte är `NULL`.

I följande exempel har rad 3 i tabellen inget pris: 

```
id  name     price
--  -------  -----
1   rädisa   7    
2   rova     4    
3   kålrot   NULL 
4   selleri  4    
```

Följande fråga hämtar det totala antalet rader:

```sql
SELECT COUNT(*) FROM Products;
```

```
COUNT(*)  
--------
4
```

Följande fråga hämtar antalet rader som har ett pris:

```sql
SELECT COUNT(price) FROM Products;
```

```
COUNT(price)
------------
3
```

Vi kan också använda `DISTINCT` för att räkna hur många olika värden som finns i en kolumn:

```sql
SELECT COUNT(DISTINCT price) FROM Products;
```

```
COUNT(DISTINCT price)
---------------------
2
```

Svaret på denna fråga blir 2 eftersom kolumnen `price` har två olika värden (4 och 7). `NULL`-värden räknas inte med.

### Hantering av tomma dataset

Aggregeringsfunktioner kan ge något oväntade resultat om datasetet som behandlas inte innehåller några rader.
Låt oss ta följande tomma tabell som exempel:

```
id  name     price
--  -------  -----
```

Funktionen `COUNT` anger antalet rader som 0: 

```sql
SELECT COUNT(price) FROM Products;
```

```
COUNT(price)
------------
0
```

Funktionen `SUM` anger däremot summan som `NULL`:

```sql
SELECT SUM(price) FROM Products;
```

```
SUM(price)
----------
NULL
```

Svaret kan vara oväntat eftersom man skulle kunna anta att summan av en tom mängd är 0 och inte `NULL`. På samma sätt ger även `MIN`, `MAX` och `AVG` svaret `NULL` för ett tomt dataset. 

Funktionen `IFNULL` kan användas för att hantera situationer där en aggregeringsfunktion kan ge resultatet `NULL`. I följande fråga betyder `IFNULL(SUM(price), 0)` i princip samma sak som `SUM(price)`, men om svaret skulle bli `NULL` ges istället 0 som svar.

```sql
SELECT IFNULL(SUM(price), 0) FROM Products;
```

```
IFNULL(SUM(price), 0)
---------------------´
0
```

{: .note-title }
Hantering av NULL-värden
<div class="note" markdown="1">
Funktionen `IFNULL(x, y)` returnerar värdet `x` om `x` inte är `NULL` och annars värdet `y`. På så sätt kan man hantera situationer där ett värde i en SQL-fråga kan vara `NULL`. Till exempel gör `IFNULL(x, 0)` att värdet blir 0 om `x` är `NULL`.

Funktionen `IFNULL` ingår inte i SQL-standarden och fungerar inte i alla databaser. Den standardenliga SQL-funktionen är `COALESCE` som kan användas på samma sätt som `IFNULL`. Till exempel är `COALESCE(x, 0)` ekvivalent med `IFNULL(x, 0)`.

Vi återkommer till en mer ingående hantering av `NULL`-värden senare i materialet.
</div>

### Gruppering

Med gruppering kan vi kombinera radvis information med den information som en aggregeringsfunktion ger. Idén är att raderna delas in i grupper baserat på de kolumner som anges i `GROUP BY`-delen, och sedan beräknas värdet av aggregeringsfunktionen separat för varje grupp.

Låt oss ta följande tabell `Employees` som exempel:

```
id  name      company   salary
--  --------  --------  ------
1   Anna      Google    8000  
2   Liisa     Google    7500  
3   Kaaleppi  Amazon    5000  
4   Uolevi    Amazon    8000  
5   Maija     Google    9500  
6   Vihtori   Facebook  5000  
```

Följande fråga hämtar antalet anställda för varje företag:

```sql
SELECT company, COUNT(*) FROM Employees GROUP BY company;
```

Frågan ger följande svar:

```
company   COUNT(*)
--------  --------
Amazon    2       
Facebook  1       
Google    3       
```

Detta betyder att Amazon har 2 anställda, Facebook har 1 anställd och Google har 3 anställda.

### Hur fungerar gruppering?

I gruppering innehåller varje grupp alla rader som har samma värden i de kolumner som används för grupperingen. Gruppringen ger en resultattabell där antalet rader motsvarar antalet grupper. Varje rad kan innehålla de kolumner som användes för gruppering samt aggregeringsfunktioner.

I den föregående frågan är villkoret för gruppering `GROUP BY` company, vilket innebär att raderna delas in i grupper baserat på kolumnen `company`. I detta fall är grupperna:

**Grupp 1**:

```
id  name      company  salary
--  --------  -------  ------
3   Kaaleppi  Amazon   5000  
4   Uolevi    Amazon   8000  
```

**Grupp 2**:

```
id  name     company   salary
--  -------  --------  ------
6   Vihtori  Facebook  5000  
```

**Grupp 3**:

```
id  name   company  salary
--  -----  -------  ------
1   Anna   Google   8000  
2   Liisa  Google   7500  
5   Maija  Google   9500  
```

Därefter beräknas antalet rader för varje grupp med funktionen `COUNT(*)`.

### Kolumner för gruppering

Rätt ofta baseras gruppering på exakt en kolumn som kolumnen `company` i det föregående exemplet. Om gruppering sker med flera kolumner består varje grupp av rader som har samma kombination av värden i de kolumner som ingår i gruppering.

Till exempel baseras gruppering i följande fråga på två kolumner:

```sql
SELECT company, salary, COUNT(*) FROM Employees GROUP BY company, salary;
```

Eftersom varje rad har en unik kombination av värden i dessa kolumner tillhör varje rad sin egen grupp i resultattabellen:

```
company   salary  COUNT(*)
--------  ------  --------
Amazon    5000    1       
Amazon    8000    1       
Facebook  5000    1       
Google    7500    1       
Google    8000    1       
Google    9500    1       
```

Efter grupperingen kan resultattabellen innehålla de kolumner som ingår i grupperingen, men inte kolumner utanför grupperingen. Till exempel skulle följande fråga inte vara korrekt:

```sql
SELECT company, name FROM Employees GROUP BY company;
```

Här ingår inte kolumnen `name` i grupperingen, vilket gör det oklart vilket värde kolumnen ska få i resultattabellen. Till exempel får resultattabellen endast en rad som hör till företaget Amazon, men företaget har två anställda med olika namn (Kaaleppi och Uolevi).

{: .note-title }
Gruppering i SQLite
<div class="note" markdown="1">
Observera att SQLite tillåter den föregående frågan där en kolumn utanför gruppering hämtas:

```sql
SELECT company, name FROM Employees GROUP BY company;
```

```
company   name   
--------  -------
Amazon    Uolevi 
Facebook  Vihtori
Google    Maija  
```

Eftersom kolumnen `name` inte ingår i gruppering kan den ha flera värden i gruppen, och resultattabellen får ett av dessa värden enligt någon bestämd logik. En sådan här fråga fungerar dock vanligtvis inte i andra databaser.
</div>

### Fler exempel på frågor

Följande fråga hämtar summan av lönerna för varje företag:

```sql
SELECT company, SUM(salary) FROM Employees GROUP BY company;
```

```
company   SUM(salary)
--------  -----------
Amazon    13000      
Facebook  5000       
Google    25000      
```

Här blir summan av Amazons löner 5000 + 8000 = 13000, summan av Facebooks löner 5000, och summan av Googles löner 8000 + 7500 + 9500 = 25000.

Följande fråga hämtar den högsta lönen:

```sql
SELECT company, MAX(salary) FROM Employees GROUP BY company;
```

```
company   MAX(salary)
--------  -----------
Amazon    8000       
Facebook  5000       
Google    9500       
```

Här är Amazons högsta lön 8000, Facebooks högsta lön 5000 och Googles högsta lön 9500.

### Namnge resultatskolumnen

Som standard får kolumnen i resultattabellen sitt namn direkt från frågan. Om vi vill kan vi ge den ett eget namn med hjälp av `AS`. På så sätt kan vi till exempel förtydliga vad sammanfattningsfrågan handlar om.

Till exempel namnges den andra kolumnen som `max_salary` i följande fråga:

```sql
SELECT
  company, MAX(salary) AS max_salary
FROM
  Employees
GROUP BY
  company;
```

```
company   max_salary
--------  ----------
Amazon    8000      
Facebook  5000      
Google    9500      
```

Observera att `AS` inte är nödvändigt att ha med i frågan. Frågan kan alternativt skrivas på följande sätt:

```sql
SELECT
  company, MAX(salary) max_salary
FROM
  Employees
GROUP BY
  company;
```

### Begränsning efter gruppering

Vi kan också lägga till `HAVING` i frågan. `HAVING` begränsar resultaten efter grupperingen. Till exempel hämtar följande fråga de företag som har minst två anställda:

```sql
SELECT
  company, COUNT(*)
FROM
  Employees
GROUP BY
  company
HAVING
  COUNT(*) >= 2;
```

```
company  COUNT(*)
-------  --------
Amazon   2       
Google   3       
```

Vi kan också använda en aggregeringsfunktion endast i `HAVING`-delen:

```sql
SELECT
  company
FROM
  Employees
GROUP BY
  company
HAVING
  COUNT(*) >= 2;
```

```
company
-------
Amazon    
Google    
```

### En överblick

SQL-strukturen kan sammanfattas enligt följande:

`SELECT` – `FROM` – `WHERE` – `GROUP BY` – `HAVING` – `ORDER BY` – `LIMIT`

Vilka av dessa delar som ingår beror på själva frågan. Detta är ändå alltid ordningen som delarna i en SQL-fråga följer i förhållande till varandra.

Låt oss betrakta en exempelfråga som innehåller alla ovan nämnda delar samtidigt. Frågan körs mot tabellen `Tasks` som innehåller uppgifter kopplade till olika projekt. Varje uppgift har en viss prioritet. En uppgift är _kritisk_ om dess prioritet är minst 3.

```
id  project_id  priority
--  ----------  --------
1   1           3       
2   1           4       
3   1           4       
4   2           1       
5   2           5       
6   3           2       
7   3           4       
8   3           5       
```

Följande fråga söker efter projekt som har minst två kritiska uppgifter. Frågan sorterar resultaten efter projektets id-nummer och ger som svar de tio första resultaten.

```sql
SELECT
  project_id, COUNT(*)
FROM
  Tasks
WHERE
  priority >= 3
GROUP BY
  project_id
HAVING
  COUNT(*) >= 2
ORDER BY
  project_id
LIMIT
  10;
```

Frågan ger följande svar:

```
project_id  COUNT(*)
----------  --------
1           3       
3           2       
```

Detta innebär att projekt 1 har tre kritiska uppgifter och att projekt 3 har två kritiska uppgifter.

Låt oss ta en närmare titt på hur frågan fungerar. Utgångspunkten för frågan är alla rader i tabellen `Tasks`. Villkoret `WHERE priority >= 3` väljer ut de kritiska uppgifterna för vidare bearbetning:

```
id  project_id  priority
--  ----------  --------
1   1           3       
2   1           4       
3   1           4       
5   2           5       
7   3           4       
8   3           5       
```

Frågan grupperar därefter raderna med `GROUP BY project_id` på följande sätt:

**Grupp 1:**

```
id  project_id  priority
--  ----------  --------
1   1           3       
2   1           4       
3   1           4       
```

**Grupp 2:**

```
id  project_id  priority
--  ----------  --------
5   2           5       
```

**Grupp 3:**

```
id  project_id  priority
--  ----------  --------
7   3           4       
8   3           5       
```

`HAVING COUNT(*) >= 2` väljer till resultattabellen de grupper som har minst två rader. I det här fallet väljs grupperna 1 och 3.

Resultattabellen innehåller för varje grupp kolumnen `project_id` och resultatet, alltså antalet rader i gruppen, för funktionen `COUNT(*)`. I det här fallet har projekt 1 tre kritiska uppgifter och projekt 3 två kritiska uppgifter.

`ORDER BY project_id` sorterar raderna i resultattabellen enligt projektets id-nummer. I det här fallet är projekten 1 och 3. `LIMIT 10` påverkar inte resultatet i det här fallet eftersom det ändå finns färre än 10 rader i tabellen.

Frågan ger följande resultattabell som svar:

```
project_id  COUNT(*)
----------  --------
1           3       
3           2       
```

## Databasen SQLite

[SQLite](https://www.sqlite.org/) är en enkel och fritt tillgänglig databashanterare som lämpar sig väl för att lära sig SQL. Du kan enkelt pröva olika SQL-funktioner med SQLite. I kursens övningar använder vi SQLite.

SQLite är ett utmärkt val av databashanterare för att öva på SQL. SQLite har dock vissa begränsningar som kan orsaka problem i verkliga tillämpningar. Andra populära och fritt tillgängliga databashanterare är [MySQL](https://www.mysql.com/) och [PostgreSQL](https://www.postgresql.org/). Dessa har många funktioner som fattas i SQLite, men är dock svårare att installera och använda.

Tur nog går det smidigt att byta mellan olika databashanterare eftersom de alla använder ett liknande SQL-språk.

### SQLite-tolk

SQLite-tolk är ett program som används för att hantera en SQLite-databas. Tolken startas genom att skriva kommandot `sqlite3` i kommandoraden. Därefter kan man skriva antingen körbara SQL-kommandon eller tolkspecifika kommandon som börjar med en punkt.

Installationen av SQLite-tolken beror på operativsystemet:

* Om du använder Linux kan du installera SQLite via pakethanteraren
* Om du använder en Mac är SQLite troligtvis redan installerat på din dator.
* Om du använder Windows kan du hämta paketet från [SQLites nedladdningssida](https://www.sqlite.org/download.html) via rubriken _command-line tools_ (det vill säga kommandoradsverktyg). Filen som behövs är den vars namn börjar med `sqlite3`.

([Video: Installation och användning av SQLite för Windows](https://www.youtube.com/watch?v=UVfvI6FYtbc))

### Esimerkki

SQLite-tulkissa tietokanta on oletuksena muistissa (_in-memory database_), jolloin se on aluksi tyhjä ja katoaa, kun tulkki suljetaan. Tämä on hyvä tapa testailla SQL-kielen ominaisuuksia. Keskustelu tulkin kanssa voi näyttää vaikkapa tältä:

```console?lang=sqlite
$ sqlite3
SQLite version 3.31.1 2020-01-27 19:55:54
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite> CREATE TABLE Products (id INTEGER PRIMARY KEY,
   ...>                        name TEXT, price INTEGER);
sqlite> .tables
Products
sqlite> INSERT INTO Products (name, price) VALUES ('retiisi', 7);
sqlite> INSERT INTO Products (name, price) VALUES ('porkkana', 5);
sqlite> INSERT INTO Products (name, price) VALUES ('nauris', 4);
sqlite> INSERT INTO Products (name, price) VALUES ('lanttu', 8);
sqlite> INSERT INTO Products (name, price) VALUES ('selleri', 4);
sqlite> SELECT * FROM Products;
1|retiisi|7
2|porkkana|5
3|nauris|4
4|lanttu|8
5|selleri|4
sqlite> .mode column
sqlite> .headers on
sqlite> SELECT * FROM Products;
id  name      price
--  --------  -----
1   retiisi   7    
2   porkkana  5    
3   nauris    4    
4   lanttu    8    
5   selleri   4    
sqlite> .quit
```

Esimerkissä luodaan aluksi taulu `Products` ja tarkastetaan sitten tulkin komennolla `.tables`, mitä tauluja tietokannassa on. Ainoa taulu on `Products`, mikä kuuluu asiaan, koska tietokanta on alussa tyhjä.

Sitten tauluun lisätään rivejä, minkä jälkeen rivit haetaan taulusta. SQLite-tulkin oletustapa näyttää tulosrivit pystyviivoin erotettuina voi olla vaikea lukea, mutta tulostusta voi parantaa tulkin komennoilla `.mode column` (jokaisella sarakkeella on kiinteä leveys) ja `.headers on` (sarakkeiden nimet näytetään).

Lopuksi suoritetaan tulkin komento `.quit`, joka sulkee tulkin.

### Tietokanta tiedostossa

Käynnistyksen yhteydessä SQLite-tulkille voi antaa parametrina tiedoston, johon tietokanta tallennetaan. Tällöin tietokannan sisältö säilyy tallessa tulkin sulkemisen jälkeen.

Seuraavassa esimerkissä tietokanta tallennetaan tiedostoon `test.db`. Tämän ansiosta tietokannan sisältö on edelleen tallessa, kun tulkki käynnistetään uudestaan.

```console?lang=sqlite
$ sqlite3 test.db
SQLite version 3.31.1 2020-01-27 19:55:54
Enter ".help" for usage hints.
sqlite> CREATE TABLE Products (id INTEGER PRIMARY KEY,
   ...>                        name TEXT, price INTEGER);
sqlite> .tables
Products
sqlite> .quit
$ sqlite3 test.db
SQLite version 3.31.1 2020-01-27 19:55:54
Enter ".help" for usage hints.
sqlite> .tables
Products
sqlite> .quit
```

### Komennot tiedostosta

Voimme myös ohjata SQLite-tulkille tiedoston, jossa olevat komennot suoritetaan peräkkäin. Tämän avulla voimme automatisoida komentojen suorittamista. Esimerkiksi voimme laatia seuraavan tiedoston `commands.sql`:

{: .code-title }
commands.sql
```
CREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER);
INSERT INTO Products (name, price) VALUES ('retiisi', 7);
INSERT INTO Products (name, price) VALUES ('porkkana', 5);
INSERT INTO Products (name, price) VALUES ('nauris', 4);
INSERT INTO Products (name, price) VALUES ('lanttu', 8);
INSERT INTO Products (name, price) VALUES ('selleri', 4);
.mode column
.headers on
SELECT * FROM Products;
```

Tämän jälkeen voimme ohjata komennot tiedostosta tulkille näin:

```console?lang=sqlite
$ sqlite3 < commands.sql
id  name      price
--  --------  -----
1   retiisi   7    
2   porkkana  5    
3   nauris    4    
4   lanttu    8    
5   selleri   4    
```
